# 组件扩展测试用例归档

## 用例表
### @LocalBuilder用例
| 测试功能                                       | 预置条件       | 输入                                                                                                | 预期输出                                                         | 是否自动 | 测试结果 |
|--------------------------------------------| -------------- |---------------------------------------------------------------------------------------------------|--------------------------------------------------------------| :------- | -------- |
| 测试自定义组件构建显示正常                 | 设备正常运行   | 进入@LocalBuilder页面，点击跳转相应页面，页面显示正常，然后返回                                                            | 子组件内容正常显示                                                    | 是       | Pass     |
| 测试按引用传参                | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，点击按钮数据发生改变，然后返回                                                        | 子组件显示正常，点击按钮,对应的子组件数据发生变化                                    | 是       | Pass     |
| 测试ArkUI提供$$按引用传递参数             | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，点击按钮数据发生改变，然后返回                                                        | 子组件显示正常，点击按钮,子组件$$传入的参数数据发生变化                                | 是       | Pass     |
| 测试@Builder和@LocalBuilder传递参数差异 | 设备正常运行   | 进入@LocalBuilder页面，点击跳转相应页面，点击按钮，组件1和组件3数据发生变化，触发UI更新，组件2数据发生变化，但不触发UI更新，然后返回                      | 页面跳转，子组件显示正常，点击按钮，组件1和组件3触发UI更新，组件2不触发UI更新                   | 是       | Pass     |
| 测试按值传递参数                       | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，页面显示正常，然后返回                                                            | 子组件内容正常显示                                                    | 是       | Pass     |
| 测试@LocalBuilder和@Builder区别说明       | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，父组件创建的自定义组件传入子组件中，页面显示正常，然后返回                                          | 子组件内容正常显示                                                    | 是       | Pass     |
| 测试@LocalBuilder在@ComponentV2修饰的自定义组件中使用        | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，点击按钮之后，@Trace修饰的组件2和组件4数据改变，触发UI更新，@Trace修饰的组件1和组件3,数据改变，但不触发UI更新，然后返回 | @Trace修饰的组件2和组件4数据改变，触发UI更新，没有@Trace修饰的组件1和组件3,数据改变，但不触发UI更新 | 是       | Pass     |
| 测试被@Builder修饰时，显示效果为“Child”；被@LocalBuilder修饰时，显示效果是“Parent”。       | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，页面显示正常，然后返回                                                            | 页面显示正常                                                       | 是       | Pass     |
| 测试可以通过使用UIUtils.makeBinding()函数、Binding类和MutableBinding类实现@Builder函数中状态变量的刷新        | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，页面显示正常，点击按钮之后，显示内容改变，然后返回                                              | 页面显示正常，点击按钮之后，显示内容改变                                         | 是       | Pass     |
| 测试@LocalBuilder函数和$$参数一起使用UI不刷新--反例       | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，页面显示正常，点击按钮之后，显示内容不更新，然后返回                                             | 页面显示正常，点击按钮之后，显示内容不更新                                        | 是       | Pass     |
| 测试@LocalBuilder函数和$$参数一起使用UI不刷新--正例        | 设备正常运行 | 进入@LocalBuilder页面，点击跳转相应页面，页面显示正常，点击按钮之后，显示内容size+1，然后返回                                          | 页面显示正常，点击按钮之后，显示内容size+1                                     | 是       | Pass     |


### @Extend用例

| 测试功能            | 预置条件       | 输入                                                                    | 预期输出                  | 是否自动 | 测试结果 |
| ------------------- | -------------- |-----------------------------------------------------------------------|-----------------------| :------- | -------- |
| 测试@Extend封装指定组件的全局方法    | 设备正常运行   | 进入@Extend页面，点击跳转相应页面，方法2传入字体参数并调用方法1，页面字体显示红色，调用方法2传入字体参数，字体大小有差异，然后返回 | 页面显示正常，字体都为红色，字体大小有差异 | 是       | Pass     |
| 测试@Extend装饰的方法调用时传递参数    | 设备正常运行 | 进入@Extend页面，点击跳转相应页面，字体颜色默认设置为红色，调用@Extend方法时传入字体参数，字体大小有差异，然后返回      | 页面显示正常，字体都为红色，字体大小有差异 | 是       | Pass     |
| 测试@Extend的参数可以为function作为Event事件的句柄    | 设备正常运行 | 进入@Extend页面，点击跳转相应页面，调用@Extend方法传入点击回调函数，点击修饰的当前组件，显示的字体内容发生改变，然后返回   | 页面显示正常，点击文案，字体内容发生改变  | 是       | Pass     |
| 测试@Extend的参数状态变量    | 设备正常运行   | 进入@Extend页面，点击跳转相应页面，页面显示正常，然后返回                                      | 页面显示正常 | 是       | Pass     |
| 测试@Extend限制条件正例    | 设备正常运行 | 进入@Extend页面，点击跳转相应页面，页面显示正常，然后返回      | 页面显示正常 | 是       | Pass     |
| 测试@Extend使用场景1    | 设备正常运行 | 进入@Extend页面，点击跳转相应页面，页面显示正常，然后返回   | 页面显示正常  | 是       | Pass     |
| 测试@Extend使用场景2    | 设备正常运行 | 进入@Extend页面，点击跳转相应页面，页面显示正常，然后返回   | 页面显示正常  | 是       | Pass     |

### @Local用例

| 测试功能            | 预置条件       | 输入                                                         | 预期输出                  | 是否自动 | 测试结果 |
| ------------------- | -------------- |------------------------------------------------------------|-----------------------| :------- | -------- |
| 测试@Local状态管理V1版本@State装饰器的局限性   | 设备正常运行   | 进入@Local页面，点击跳转相应页面，页面显示正常，然后返回                            | 页面显示正常 | 是       | Pass     |
| 测试@Local装饰的变量观测简单类型变化   | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰的变量观测类对象整体赋值的变化    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰的变量为简单类型数组时的变化   | 设备正常运行   | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰的变量为嵌套类或对象数组时   | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰的变量观测对象整体变化    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，第1行数据不变，第2行数据改变，页面ui更新，然后返回 | 页面显示正常，点击按钮，第1行数据不变，第2行数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰Array类型变量    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰Date类型变量    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，显示日期数据改变，页面ui更新，然后返回       | 页面显示正常，点击按钮，显示日期数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰Map类型变量    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰Set类型变量    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local装饰联合类型    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，数据改变，页面ui更新，然后返回           | 页面显示正常，点击按钮，数据改变，页面ui更新 | 是       | Pass     |
| 测试@Local常见问题：复杂类型常量重复赋值给状态变量触发刷新    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，然后返回                            | 页面显示正常  | 是       | Pass     |
| 测试@Local常见问题：复杂类型常量重复赋值给状态变量触发刷新--使用UIUtils.getTarget()方法示例   | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，然后返回                            | 页面显示正常  | 是       | Pass     |
| 测试@Local状态管理V2中使用animateTo动画效果异常--animateTo暂不支持直接在状态管理V2中使用    | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，点击按钮，绿色方块只变化1次，然后返回             | 页面显示正常，点击按钮，绿色方块只变化1次  | 是       | Pass     |
| 测试@Local状态管理V2中使用animateTo动画效果异常--通过下面的方法暂时获得预期的显示效果   | 设备正常运行 | 进入@Local页面，点击跳转相应页面，页面显示正常，每次点击按钮，绿色方块变化1次，然后返回            | 页面显示正常，每次点击按钮，绿色方块变化1次  | 是       | Pass     |


### $$语法用例

| 测试功能                             | 预置条件       | 输入                                       | 预期输出                  | 是否自动 | 测试结果 |
|----------------------------------| -------------- |------------------------------------------|-----------------------| :------- | -------- |
| 测试$$语法使用示例：以TextInput方法的text参数为例 | 设备正常运行   | 进入$$页面，点击跳转相应页面，点击输入框，输入文案，页面显示对应文案，然后返回 | 点击输入框，输入文案，页面显示对应文案 | 是       | Pass     |

### PersistenceV2: 持久化存储UI状态用例

| 测试功能                                                   | 预置条件       | 输入                                                  | 预期输出                  | 是否自动 | 测试结果 |
|--------------------------------------------------------| -------------- |-----------------------------------------------------|-----------------------| :------- | -------- |
| 测试PersistenceV2:在两个页面之间存储数据--页面1                       | 设备正常运行   | 进入PersistenceV2页面，点击跳转相应页面，页面显示正常，然后返回              | 页面显示正常 | 是       | Pass     |
| 测试PersistenceV2:在两个页面之间存储数据--页面2                       | 设备正常运行   | 进入PersistenceV2页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass     |
| 测试PersistenceV2使用globalConnect存储数据                     | 设备正常运行   | 进入PersistenceV2页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass     |
| 测试PersistenceV2在不同的module中使用connect和globalConnect--模块1 | 设备正常运行   | 进入PersistenceV2页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass     |
| 测试PersistenceV2-connect向globalConnect迁移实现--模块1         | 设备正常运行   | 进入PersistenceV2页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass     |
| 测试PersistenceV2-connect向globalConnect迁移实现--模块2         | 设备正常运行   | 进入PersistenceV2页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass     |


### 数据对象状态变量的迁移指导用例

| 测试功能                             | 预置条件       | 输入                                                              | 预期输出                  | 是否自动 | 测试结果 |
|----------------------------------| -------------- |-----------------------------------------------------------------|-----------------------| :------- | -------- |
| 测试嵌套对象属性观察方法V1实现 | 设备正常运行   | 进入数据对象状态变量的迁移指导页面，点击跳转相应页面，页面显示正常，点击按钮city+a，显示的city名+a，然后返回    | 页面显示正常，点击按钮city+a，显示的city名+a | 是       | Pass     |
| 测试嵌套对象属性V2迁移策略 | 设备正常运行   | 进入数据对象状态变量的迁移指导页面，点击跳转相应页面，页面显示正常，点击按钮city+a，显示的city名+a，然后返回    | 页面显示正常，点击按钮city+a，显示的city名+a | 是       | Pass     |
| 测试类属性变化观测V1实现 | 设备正常运行   | 进入数据对象状态变量的迁移指导页面，点击跳转相应页面，页面显示正常，点击按钮Increase age，显示的数字+1，然后返回 | 页面显示正常，点击按钮Increase age，显示的数字+1 | 是       | Pass     |
| 测试类属性变化观测V2迁移策略 | 设备正常运行   | 进入数据对象状态变量的迁移指导页面，点击跳转相应页面，页面显示正常，点击按钮Increase age，显示的数字+1，然后返回             | 页面显示正常，点击按钮Increase age，显示的数字+1 | 是       | Pass     |


###  @Monitor用例

| 测试功能                                                                  | 预置条件       | 输入                                                                                              | 预期输出                                    | 是否自动 | 测试结果 |
|-----------------------------------------------------------------------| -------------- |-------------------------------------------------------------------------------------------------|-----------------------------------------| :------- | -------- |
| 测试状态管理V1版本@Watch装饰器的局限性                                               | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，分别点击按钮，控制台日志输出对应日志内容，然后返回                                          | 页面显示正常，分别点击按钮，控制台日志输出对应日志内容             | 是       | Pass     |
| 测试@ComponentV2：@Monitor可以同时监听多个状态变量，这些变量名之间用","隔开                     | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@ComponentV2：@Monitor监听类属性的变化需要类属性被@Trace装饰                         | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击第1个按钮，页面内容发生改变，点击第2个按钮，页面内容不变化，控制台日志输出对应日志内容，然后返回                | 页面显示正常，点击第1个按钮，页面内容发生改变，点击第2个按钮，页面内容不变化 | 是       | Pass     |
| 测试@ObservedV2：@Monitor可以同时监听多个属性，这些属性之间用","隔开                         | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@ObservedV2：@Monitor可以监听深层属性的变化，该深层属性需要被@Trace装饰                    | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@ObservedV2：@Monitor在继承类场景下，可以在继承链中对同一个属性进行多次监听                     | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor通用监听能力：@Monitor监听数组中的项，包括多维数组，对象数组                          | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor通用监听能力：@Monitor监听对象整体改变，但监听的属性不变时，不触发@Monitor回调             | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor通用监听能力：在一次事件中多次改变被@Monitor监听的属性，以最后一次修改为准                   | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor限制条件：当一个类中存在对一个属性的多次监听时，只有最后一个定义的监听方法会生效                    | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor限制条件：当@Monitor传入多个路径参数时，以参数的全拼接结果判断是否重复监听。全拼接时会在参数间加空格，以区分不同参数 | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor使用场景：监听深层属性变化，@Monitor可以监听深层属性的变化，并能够根据更改前后的值做分类处理          | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，页面value发生改变，然后返回                                              | 页面显示正常，点击按钮，页面value发生改变               | 是       | Pass     |
| 测试@Monitor常见问题：@ComponentV2自定义组件中，@Monitor对变量监听的生效及失效时间               | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击show/hide Child按钮，页面显示和隐藏新的组件，点击change按钮，页面无ui更新，然后返回            | 页面显示正常，点击show/hide Child按钮，页面显示和隐藏新的组件，点击change按钮，页面无ui更新               | 是       | Pass     |
| 测试@Monitor常见问题：类中@Monitor对变量监听的生效及失效时间                                | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor常见问题：@Monitor监听类--由于类的实际销毁释放依赖于垃圾回收机制，导致类中定义的@Monitor仍在监听变化的情况 | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击change showFlag按钮，页面显示和隐藏新的组件，点击change number按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击change showFlag按钮，页面显示和隐藏新的组件，点击change number按钮，数据更改，页面ui更新               | 是       | Pass     |
| 测试@Monitor常见问题：@Monitor监听类--管理@Monitor的失效时间--将@Monitor定义在自定义组件中       | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击change showFlag按钮，页面显示和隐藏新的组件，点击change number按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击change showFlag按钮，页面显示和隐藏新的组件，点击change number按钮，数据更改，页面ui更新               | 是       | Pass     |
| 测试@Monitor常见问题：@Monitor监听类--管理@Monitor的失效时间--主动置空监听的对象                | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击change showFlag按钮，页面显示和隐藏新的组件，点击change number按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击change showFlag按钮，页面显示和隐藏新的组件，点击change number按钮，数据更改，页面ui更新               | 是       | Pass     |
| 测试@Monitor常见问题：正确设置@Monitor入参--反例1                  | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor常见问题：正确设置@Monitor入参--正例1                  | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor常见问题：正确设置@Monitor入参--反例2                  | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor常见问题：正确设置@Monitor入参--正例2                  | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor常见问题：直接监听状态变量本身                  | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，控制台日志输出对应日志内容，然后返回                                            | 页面显示正常，点击按钮，控制台日志输出对应日志内容               | 是       | Pass     |
| 测试@Monitor常见问题：无法监听变量从可访问变为不可访问和从不可访问变为可访问                  | 设备正常运行   | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，页面数据更改，ui更新，然后返回                                              | 进入@Monitor页面，点击跳转相应页面，页面显示正常，点击按钮，页面数据更改，ui更新，然后返回               | 是       | Pass     |

### @Provide装饰器和@Consume装饰器用例

| 测试功能                             | 预置条件       | 输入                                                                       | 预期输出                  | 是否自动 | 测试结果 |
|----------------------------------| -------------- |--------------------------------------------------------------------------|-----------------------| :------- | -------- |
| 测试@Consume装饰的变量初始化正例 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，然后返回                         | 页面显示正常| 是       | Pass     |
| 测试@Consume装饰的变量初始化正例2 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，然后返回                         | 页面显示正常 | 是       | Pass     |
| 测试@Provide变量与后代组件中@Consume变量进行双向同步 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案和按钮上的文案改变，然后返回   | 页面显示正常，点击任意按钮，显示的文案和按钮上的文案改变 | 是       | Pass     |
| 测试@Consume装饰Map类型变量 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，显示的文案发生改变，然后返回          | 页面显示正常，点击按钮，显示的文案发生改变 | 是       | Pass     |
| 测试装饰Set类型变量 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，显示的文案发生改变，然后返回          | 页面显示正常，点击按钮，显示的文案发生改变 | 是       | Pass     |
| 测试装饰Date类型变量 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，显示的日期发生改变，然后返回          | 页面显示正常，点击按钮，显示的日期发生改变 | 是       | Pass     |
| 测试Provide和Consume支持联合类型实例 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案和按钮上的文案改变，然后返回 | 页面显示正常，点击任意按钮，显示的文案和按钮上的文案改变 | 是       | Pass     |
| 测试@Provide支持allowOverride参数 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案发生改变，然后返回 | 页面显示正常，点击任意按钮，显示的文案发生改变 | 是       | Pass     |
| 测试@Consume装饰的变量支持设置默认值 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案发生改变，然后返回   | 页面显示正常，点击任意按钮，显示的文案发生改变 | 是       | Pass     |
| 测试和@Provide建立双向同步 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案发生改变，然后返回 | 页面显示正常，点击任意按钮，显示的文案发生改变 | 是       | Pass     |
| 测试@BuilderParam尾随闭包@Provide未定义错误 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案发生改变，然后返回 | 页面显示正常，点击任意按钮，显示的文案发生改变 | 是       | Pass     |
| 测试a.b(this.object)不触发UI刷新 | 设备正常运行   | 进入@Provide装饰器和@Consume装饰器页面，点击跳转相应页面，页面显示正常，点击任意按钮，显示的文案发生改变，然后返回 | 页面显示正常，点击任意按钮，显示的文案发生改变 | 是       | Pass     |

### 应用内状态变量和其它场景迁移指导

| 测试功能                             | 预置条件       | 输入                                                                       | 预期输出                  | 是否自动 | 测试结果 |
|:---------------------------------| -------------- |--------------------------------------------------------------------------|-----------------------| :------- | -------- |
| 使用@LocalStorageLink：在两个页面之间存储数据--并且跳转到pag2 | 设备正常运行 | 进入pag1页面，点击跳转相应页面，页面显示正常，然后返回       | 页面显示正常 | 是       | Pass     |
| 使用@LocalStorageLink：存储数据pag2页面 | 设备正常运行   | 进入页面，页面显示正常，然后返回                         | 页面显示正常 | 是       | Pass     |
| 声明@ObservedV2：在两个页面之间存储数据--并且跳转到pag2      | 设备正常运行 | 进入pag1页面，点击跳转相应页面，页面显示正常，然后返回       | 页面显示正常 | 是       | Pass     |
| 声明@ObservedV2：存储数据pag2页面                            | 设备正常运行 | 进入页面，页面显示正常，然后返回                             | 页面显示正常 | 是       | Pass     |
| 调用LocalStorage：在两个页面之间存储数据--并且跳转到pag2     | 设备正常运行 | 进入pag1页面，点击跳转相应页面，页面显示正常，然后返回       | 页面显示正常 | 是       | Pass     |
| 调用LocalStorage：存储数据pag2页面                           | 设备正常运行 | 进入页面，页面显示正常，然后返回                             | 页面显示正常 | 是       | Pass     |
| 自定义组件：点击按钮跳转到pegeA-->再次点击按钮跳转到pegeB-->再次点击按钮跳转到pegeC | 设备正常运行 | 进入页面，点击跳转相应页面，页面显示正常，然后返回           | 页面显示正常 | 是       | Pass     |
| 实现类似LocalStorage：点击打开页面                           | 设备正常运行 | 进入页面，页面显示正常，然后返回                             | 页面显示正常 | 是       | Pass     |
| AppStorageV1：点击文字数字增加1                              | 设备正常运行 | 进入页面，点击第一个文字数字增加1，页面显示正常，然后返回    | 页面显示正常 | 是       | Pass     |
| AppStorageV1：点击文字数字增加1                              | 设备正常运行 | 进入页面，点击第一个文字数字增加1，页面显示正常，然后返回    | 页面显示正常 | 是       | Pass     |
| 可以使用AppStorageV2：点击文字数字增加1                      | 设备正常运行 | 进入页面，点击第一个文字数字增加1，页面显示正常，然后返回    | 页面显示正常 | 是       | Pass     |
| 可以使用AppStorageV2：点击文字数字增加1                      | 设备正常运行 | 进入页面，点击第一个文字数字增加1，页面显示正常，然后返回    | 页面显示正常 | 是       | Pass |
| 类似于@StorageProp：点击第一个按钮数字增加100，点击第二个按钮无页面改变 | 设备正常运行 | 进入页面，点击第一个按钮数字增加100，点击第二个按钮无页面改变，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| 类似于@StorageProp：点击第一个按钮数字增加100，点击第二个按钮无页面改变 | 设备正常运行 | 进入页面，点击第一个按钮数字增加100，点击第二个按钮无页面改变，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| 开发者可以使用@Monitor和@Local：点击第一个按钮数字增加100，点击第二个按钮无页面改变 | 设备正常运行 | 进入页面，点击第一个按钮数字增加100，点击第二个按钮无页面改变，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| 开发者可以使用@Monitor和@Local：点击第一个按钮数字增加100，点击第二个按钮无页面改变 | 设备正常运行 | 进入页面，点击第一个按钮数字增加100，点击第二个按钮无页面改变，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| Environment：展示文字                                        | 设备正常运行 | 进入页面，页面显示正常，然后返回                             | 页面显示正常 | 是       | Pass |
| Environment：展示文字                                        | 设备正常运行 | 进入页面，页面显示正常，然后返回                             | 页面显示正常 | 是       | Pass |
| V1中PersistentStorage：点击文字刷新样式                      | 设备正常运行 | 进入页面，页面显示正常，点击文字，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| 将PersistentStorage：点击文字刷新样式                        | 设备正常运行 | 进入页面，页面显示正常，点击文字，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| 通常父组件使用：点击文字刷新样式                             | 设备正常运行 | 进入页面，页面显示正常，点击文字，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| V1:ChildrenMainSize：点击按钮刷新样式                        | 设备正常运行 | 进入页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| V2:ChildrenMainSize：点击按钮刷新样式                        | 设备正常运行 | 进入页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| V1:WaterFlowSections：点击按钮刷新样式                       | 设备正常运行 | 进入页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| V2:WaterFlowSections：点击按钮刷新样式                       | 设备正常运行 | 进入页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常 | 是       | Pass |
| V1:通过attributeModifier：点击按钮改变按钮背景色             | 设备正常运行 | 进入页面，点击按钮改变按钮背景色，页面显示正常，然后返回     | 页面显示正常 | 是       | Pass |
| V2:通过attributeModifier：点击按钮改变按钮背景色             | 设备正常运行 | 进入页面，点击按钮改变按钮背景色，页面显示正常，然后返回     | 页面显示正常 | 是       | Pass |
| V1:动态设置组件：点击按钮添加不同样式边框                    | 设备正常运行 | 进入页面，点击按钮添加不同样式边框，页面显示正常，然后返回   | 页面显示正常 | 是       | Pass |
| V2:动态设置组件：点击按钮添加不同样式边框                    | 设备正常运行 | 进入页面，点击按钮添加不同样式边框，页面显示正常，然后返回   | 页面显示正常 | 是       | Pass |
| V1:组件Modifier：点击上方按钮改变文字颜色大小，点击下方按钮给文字添加背景色 | 设备正常运行 | 进入页面，点击上方按钮改变文字颜色大小，点击下方按钮给文字添加背景色，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| V2:组件Modifier：点击上方按钮改变文字颜色大小，点击下方按钮给文字添加背景色 | 设备正常运行 | 进入页面，点击上方按钮改变文字颜色大小，点击下方按钮给文字添加背景色，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| V1:将属性直接设置给组件：点击按钮给上方按钮添加边框          | 设备正常运行 | 进入页面，点击下方按钮给上方按钮添加边框，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |
| V2:将属性直接设置给组件：点击按钮给上方按钮添加边框          | 设备正常运行 | 进入页面，点击下方按钮给上方按钮添加边框，页面显示正常，然后返回 | 页面显示正常 | 是       | Pass |



### @Param用例

| 测试功能                                             | 预置条件     | 输入                                                         | 预期输出                                         | 是否自动 | 测试结果 |
| ---------------------------------------------------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------ | :------- | -------- |
| 测试@Param状态管理V1版本接受外部传入的装饰器的局限性 | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param装饰的变量具有被观测变化的能力             | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param装饰的变量类型为类对象时                   | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param装饰的变量为简单类型数组时                 | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param当装饰的变量是嵌套类或对象数组时           | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param从父组件到子组件变量传递与同步             | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param装饰Array类型变量                          | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新     | 是       | Pass     |
| 测试@Param装饰Date类型变量                           | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，日期数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，日期数据更改，页面ui更新 | 是       | Pass     |
| 测试@Param装饰Map类型变量                            | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，日期数据更改，页面ui更新 | 是       | Pass     |
| 测试@Param装饰Set类型变量                            | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，日期数据更改，页面ui更新 | 是       | Pass     |
| 测试@Param装饰联合类型类型                           | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，日期数据更改，页面ui更新 | 是       | Pass     |
| 测试@Param装饰的变量是对象类型                       | 设备正常运行 | 进入@Param装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，日期数据更改，页面ui更新 | 是       | Pass     |

### @State装饰器用例

| 测试功能                                                     | 预置条件     | 输入                                                         | 预期输出                                                     | 是否自动 | 测试结果 |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | :------- | -------- |
| 测试@State使用场景：装饰简单类型的变量                       | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，按钮数字+1，页面ui更新，然后返回 | 页面显示正常，点击按钮，按钮数字+1，页面ui更新               | 是       | Pass     |
| 测试@State观察变化和行为表现：当装饰的数据类型为class或Object | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击第1个按钮，数据改变，页面ui更新，点击其他按钮，数据改变，页面ui不更新，然后返回 | 页面显示正常，点击第1个按钮，数据改变，页面ui更新，点击其他按钮，数据改变，页面ui不更新 | 是       | Pass     |
| 测试@State观察变化和行为表现：当装饰的对象是array            | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
| 测试@State使用场景：装饰class对象类型的变量                  | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
| 测试@State使用场景：装饰Map类型变量                          | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
| 测试@State使用场景：装饰Set类型变量                          | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
| 测试@State使用场景：装饰Date类型变量                         | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，日期数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，日期数据更改，页面ui更新             | 是       | Pass     |
| 测试@State使用场景：State支持联合类型实例                    | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
| 测试@State常见问题：使用箭头函数改变状态变量未生效--反例     | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，组件颜色不改变，页面ui不更新，然后返回 | 页面显示正常，点击按钮，数据更改，组件颜色不改变，页面ui不更新 | 是       | Pass     |
| 测试@State常见问题：使用箭头函数改变状态变量未生效--正例     | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，组件颜色改变，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，组件颜色改变，页面ui更新   | 是       | Pass     |
| 测试@State常见问题：类的构造函数中通过捕获this修改变量无法观察--反例 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常                                                 | 是       | Pass     |
| 测试@State常见问题：类的构造函数中通过捕获this修改变量无法观察--正例 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常                                                 | 是       | Pass     |
| 测试@State常见问题：状态变量只能影响其直接绑定的UI组件的刷新--示例1 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，第2个数据改变，对应页面ui更新，然后返回 | 页面显示正常，点击按钮，第2个数据改变，对应页面ui更新        | 是       | Pass     |
| 测试@State常见问题：状态变量只能影响其直接绑定的UI组件的刷新--示例2 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，第1个数据改变，对应页面ui更新，然后返回 | 页面显示正常，点击按钮，第1个数据改变，对应页面ui更新        | 是       | Pass     |
| 测试@State常见问题：状态变量只能影响其直接绑定的UI组件的刷新--示例3 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，第2个数据改变，对应页面ui更新，然后返回 | 页面显示正常，点击按钮，第2个数据改变，对应页面ui更新        | 是       | Pass     |
| 测试@State常见问题：复杂类型常量重复赋值给状态变量触发刷新   | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui不更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui不更新               | 是       | Pass     |
| 测试@State常见问题：避免复杂类型常量重复赋值给状态变量触发刷新--方法一：增加@Observed | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui不更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui不更新               | 是       | Pass     |
| 测试@State常见问题：避免复杂类型常量重复赋值给状态变量触发刷新--方法二：使用UIUtils.getTarget()获取原始对象 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui不更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui不更新               | 是       | Pass     |
| 测试@State常见问题：不允许在build里改状态变量--示例01        | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，然后返回 | 页面显示正常                                                 | 是       | Pass     |
| 测试@State常见问题：使用a.b(this.object)形式调用，不会触发UI刷新--反例 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui不更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui不更新               | 是       | Pass     |
| 测试@State常见问题：使用a.b(this.object)形式调用，不会触发UI刷新--正例 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
| 测试@State常见问题：用注册回调的方式更改状态变量需要执行解注册 | 设备正常运行 | 进入@State装饰器页面，点击跳转相应页面，页面显示正常，点击按钮，数据更改，页面ui更新，然后返回 | 页面显示正常，点击按钮，数据更改，页面ui更新                 | 是       | Pass     |
